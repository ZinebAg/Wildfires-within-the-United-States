---
title: "R Notebook"
output: html_notebook
---
````{r, include=FALSE}

library(ggplot2)
library(tidyr)
library(dplyr)
library(corrplot)
library(maps)
library(tidyverse)
library(Hmisc)
library(zoo)
library(hrbrthemes) 
library(pscl)
library('plot.matrix')
library('psych')
library(bookdown)
library(quantreg)
library(latex2exp)
library(cowplot)
library(reshape2)
library(stargazer)
library(knitr)
library(stargazer)
````
### Land covers and meteorogical correlation
```{r, include = FALSE}
load ("../Data/data_train_DF.RData")
df <- data_train_DF
#Remove the NA values from the data
df<-df[!is.na(df$CNT),] 
df<-df[!is.na(df$BA),]
```


We want to understand the correlation between land covers and meteorological variables. To do so, we are going to clean our data first, rename the variables by their description so that we can easily analyze our results and then compute the correlation between the variables. The problem is that when trying to output the matrix, we get a warning saying that the matrix is too big. To get an glimpse of what variable can be highly related, we are going to output the correlation between a pair of land cover and meteorological variable when it is bigger than a threshold manually set.


```{r, echo = FALSE}
remove = c("CNT","BA","lon","lat","area","year","month","altiMean","altiSD")
data =df[, -which(names(df)%in% remove)]
data<-data%>% dplyr::rename(CR=lc1,CRherb = lc2, MosaicC = lc3, MosaicVege = lc4,
                            TBE=lc5,TBD = lc6, TNE  = lc7, TND = lc8, TreeMixed =lc9,
                            MosaicTreeShrub= lc10, Shrub= lc11, Grass = lc12,
                            Svege=lc13,
                            TreeFlood=lc14,ShrubFlood = lc15, urban = lc16, 
                            BareAreas =lc17, Water = lc18,NSwind=clim1, WEwind=clim2, 
                            dew_temperature=clim3, temperature=clim4, 
                            potential_evaporation=clim5, solar_radiation= clim6,
                            thermal_radiation=clim7, pressure=clim8, evaporation=clim9, 
                            precipitation=clim10)
FindCorForLC <- function (x,methode,threshold){
  #Want to show if y has an impact on x
  X = data[,x]
  correlations <- 0
  for (y in 1:10){
    Y = data[,18+y]
    c = cor(X,Y,method=methode)
    if (c > threshold | c < -threshold){
      correlations = c(correlations, y)
      print (paste("cor(",x,",",y,")=",c,sep=""))
    }
  }
  return(correlations)
}
corr1 = FindCorForLC(1,"pearson",0.6)
corr2 = FindCorForLC(2,"pearson",0.6)
corr3 = FindCorForLC(3,"pearson",0.6)
corr4 =FindCorForLC(4,"pearson",0.6)
corr5 =FindCorForLC(5,"pearson",0.6)
corr6 =FindCorForLC(6,"pearson",0.6)
corr7=FindCorForLC(7,"pearson",0.6)
corr8 =FindCorForLC(8,"pearson",0.6)
corr9 =FindCorForLC(9,"pearson",0.6)
corr10 =FindCorForLC(10,"pearson",0.6)
corr11 =FindCorForLC(11,"pearson",0.6)
corr12 =FindCorForLC(12,"pearson",0.6)
corr13 =FindCorForLC(13,"pearson",0.6)
corr14 =FindCorForLC(14,"pearson",0.6)
corr15 =FindCorForLC(15,"pearson",0.6)
corr16 =FindCorForLC(16,"pearson",0.6)
corr17 =FindCorForLC(17,"pearson",0.6)
corr18 =FindCorForLC(18,"pearson",0.6)
```


Here, we choose a threshold of 0.6 and none of the correlations has been displayed except one. This means that those who have not been printed are less that 0.6. We get that the correlation between the shrublands and the surface net thermal radiation is of -0.72. This seems normal: the more radiation is issued by the surface, the less shrub we get. But the results are not as good as expected. In fact, when printing all the correlations (threshold = 0) we remark that the values are very small. This can come from the fact that there are no correlations between the variables or that the dependence is not linear here. The first option seems less likely. So we are going to compute the correlation with spearman method to see if the relation between the variables is monotonic. 


```{r, echo = FALSE}
corr1 = FindCorForLC(1,"spearman",0.6)
corr2 = FindCorForLC(2,"spearman",0.6)
corr3 = FindCorForLC(3,"spearman",0.6)
corr4 = FindCorForLC(4,"spearman",0.6)
corr5 = FindCorForLC(5,"spearman",0.6)
corr6 = FindCorForLC(6,"spearman",0.6)
corr7 = FindCorForLC(7,"spearman",0.6)
corr8 = FindCorForLC(8,"spearman",0.6)
corr9 = FindCorForLC(9,"spearman",0.6)
corr10 = FindCorForLC(10,"spearman",0.6)
corr11 = FindCorForLC(11,"spearman",0.6)
corr12 = FindCorForLC(12,"spearman",0.6)
corr13 = FindCorForLC(13,"spearman",0.6)
corr14 = FindCorForLC(14,"spearman",0.6)
corr15 = FindCorForLC(15,"spearman",0.6)
corr16 = FindCorForLC(16,"spearman",0.6)
corr17 = FindCorForLC(17,"spearman",0.6)
corr18 = FindCorForLC(18,"spearman",0.6)
```


Now by changing the method, we observe that we get that the land cover variable  11 (shrubland) and the surface net thermal radiation are correlated, same result as earlier. And, we also get that the water, urban and surface pressure are correlated. The pressure in the water is higher that the atmospheric pressure and increases with the depth. The pollution of the air explains the positive correlation between urban lands and surface pressure. To visualize our results and try to show more, we are going to regroup our data so that we can compute a correlation matrix with again spearman method. This part consists of taking variables of land covers that are similar with common characteristics ans sum them together.


```{r, fig.cap="Correlation heatmap after regrouping the land covers with meteorological variables",fig.width=7, fig.height=7, echo =FALSE}
dataMod = data
Rainfed = dataMod$CR+ dataMod$CRherb
dataMod$Rainfed = Rainfed
remove = c("CR","CRherb")
dataMod = dataMod[,-which(names(dataMod)%in% remove)]
Trees = dataMod$TBE +dataMod$TBD +dataMod$TNE + dataMod$TND+ dataMod$TreeMixed+ dataMod$TreeFlood 
dataMod$Trees <- Trees
remove = c("TBE", "TBD","TNE","TND","TreeMixed","TreeFlood")
dataMod =dataMod[, -which(names(dataMod)%in% remove)]
vegetation = dataMod$MosaicVege + dataMod$Svege+ dataMod$Grass
dataMod$vegetation = vegetation 
remove = c("MosaicVege","Svege","Grass")
dataMod = dataMod[, -which(names(dataMod)%in% remove)]
ShrubArea = dataMod$MosaicTreeShrub + dataMod$Shrub +dataMod$ShrubFlood
remove = c("MosaicTreeShrub","Shrub","ShrubFlood")
dataMod = dataMod[, -which(names(dataMod)%in% remove)]
dataMod$ShrubArea = ShrubArea
 
dataMod <-dataMod %>% relocate(Rainfed,Trees,vegetation,ShrubArea)
corrplot(cor(dataMod, method = "spearman"), method = "color", addCoef.col="black",tl.cex = 0.8, cl.cex = 0.8, number.cex = 0.7, number.digits = 2)
```


This technique has been useful to represent our previous result. Also in the figure, Evaporation is negatively correlated with the trees, meaning the more trees there are, less evaporation there is. For the next project, one can think of trying to find correlation between other land cover and meteorological data by plotting the scatter plot to find a curve that approximate the data to look for non monotonic or non linear correlation.

### Spreading fire based on the type of land cover
First, to analyze the spread of a fire, let us look for the distribution of the number of fires in a grid during a month. 



```{r,fig.cap="Histogram representing the number of wild fires in a grid from 1993 to 2015",echo = FALSE}
hist <- hist(df$CNT,breaks=seq(-0.5,max(df$CNT)+0.5,1), xlab="Fires ", ylab=" Frequency")
```


We remark that most of the values are close to 0 and because of the outliers we cannot see the distribution very clearly. We thus filter the outliers to have a better view of the distrubution. 


```{r, fig.cap="Histogram representing the number of wild fires in a grid from 1993 to 2015 (without outliers)",echo = FALSE}
df1 <-df%>% filter(CNT<20)
hist = hist(df1$CNT, breaks = seq(-0.5, max(df1$CNT)+0.5, 1), main= "Number of fires in a grid per month", xlab = "Fires")
``` 


Now, since the aim of this part is to predict the spread of a fire given the land covers data. Let us plot the distribution of the number of fire according to each land cover variable. 

```{r, echo = FALSE}
sample <- df [sample(1:nrow(df),10000),]
#1
plot1 <- ggplot ()+
  geom_point(data = sample, aes(x = lc1, y= CNT))
#2
plot2 <-ggplot ()+
  geom_point(data = sample, aes(x = lc2, y= CNT))
#3
plot3 <-ggplot ()+
  geom_point(data = sample, aes(x = lc3, y= CNT))
#4
plot4 <-ggplot ()+
  geom_point(data = sample, aes(x = lc4, y= CNT))
#5
plot5 <-ggplot ()+
  geom_point(data = sample, aes(x = lc5, y= CNT))
#6
plot6 <-ggplot ()+
  geom_point(data = sample, aes(x = lc6, y= CNT))
#7
plot7<- ggplot ()+
  geom_point(data = sample, aes(x = lc7, y= CNT))
#8
plot8<-ggplot ()+
  geom_point(data = sample, aes(x = lc8, y= CNT))
#9
plot9<-ggplot ()+
  geom_point(data = sample, aes(x = lc9, y= CNT))
#10
plot10<-ggplot ()+
  geom_point(data = sample, aes(x = lc10, y= CNT))
#11
plot11<-ggplot ()+
  geom_point(data = sample, aes(x = lc11, y= CNT))
#12
plot12<-ggplot ()+
  geom_point(data = sample, aes(x = lc12, y= CNT))
#13
plot13<-ggplot ()+
  geom_point(data = sample, aes(x = lc13, y= CNT))
#14
plot14<-ggplot ()+
  geom_point(data = sample, aes(x = lc14, y= CNT))
#15
plot15<-ggplot ()+
  geom_point(data = sample, aes(x = lc15, y= CNT))
#16
plot16<- ggplot ()+
  geom_point(data = sample, aes(x = lc16, y= CNT))
#17
plot17 <-ggplot ()+
  geom_point(data = sample, aes(x = lc17, y= CNT))
#18
plot18 <-ggplot ()+
  geom_point(data = sample, aes(x = lc18, y= CNT))
cowplot::plot_grid(plot1, plot2, plot3, plot4,plot5, plot6, plot7,plot8,plot9)
```


```{r,fig.cap="Distribution of the number of fire according to each land cover", echo = FALSE}
cowplot::plot_grid(plot10,plot11,plot12,plot13,plot14,plot15,plot16,plot17,plot18)
```

Most of the plots have a distribution that can make this of Poisson distribution, or power laws in certain case. 

In this section, we try to model the fact that there was a fire in a grid for a given month  given the land cover specification of the grid. The problem is that we have the number of fire in the grid. One can think of using the zero inflated Poisson regression. In fact, the zero inflated Poisson is used to count data with excess zeros and overdispersion, which describe well our data. It combines the Poisson distribution and the logit distribution.


```{r,tab.cap="Table of Zero Poisson regression results", echo = FALSE}
m1<-zeroinfl(CNT~lc1+lc2+lc3+lc4+lc5+lc6+lc7+lc8+lc9+lc10+lc11+lc12+lc13+lc14+lc15+lc16+lc17+lc18, data = df)
summary(m1)
```



Below, you can find a block of output containing Poisson regression coefficients for each of the variables along with the standard errors, z-score and p-values for the coefficients. A second block follows with the inflation model which includes logit coefficients for predicting excess zeros. All of the predictions in both the count and inflation portion are statistically significant ( all p-values are very small) except for the land cover 3 in the count model. But otherwise this means that the null hypothesis that the coefficient is equal to 0 is rejected for all the coefficients. Hence this model fits the data significantly better than the null model.

## Prediction of the number of fire depending of the land covers : 

We are going to divide our data set  in two sets : the training set to build the model and a test set to predict the number of fires per grid. One way to split our data is to take all the data all data from 1993 to 2014 and predict the number of fire in 2015. Or also, we can randomly select 70% of our data to train and the rest to test the data. We will use the first technique split: 



```{r, echo = FALSE}
test <- subset(df, year ==2015)
train <- subset(df, year != 2015)
m1<-zeroinfl(CNT~lc1+lc2+lc3+lc4+lc5+lc6+lc7+lc8+lc9+lc10+lc11+lc12+lc13+lc14+lc15+lc16+lc17+lc18, data = train)
#check if the actual model is better to a null null mode without predictors : 
mnull <- update(m1, .~1)
pchisq (2* (logLik(m1)-logLik(mnull)), df =18, lower.tail = FALSE)
```


Since we have 18 predictor variable in the model, we take 18 degrees of freedom for the chi-squred test. Our model is statistically significant.


```{r, echo = FALSE}
stay = c("lc1","lc2","lc3","lc4","lc5","lc6","lc7","lc8","lc9","lc10","lc11","lc12","lc13","lc14","lc15","lc16","lc17","lc18")
new_test = test[, which(names(df)%in% stay)]
#test$CNT <- predict(m1, )
new_test$CNT<- predict(m1,new_test)
``` 

```{r, echo = FALSE}
plot(new_test$CNT,test$CNT, xlab = "Predicted Values", ylab = "Observed Values")
```

```{r, echo = FALSE}
effect_plot(new_test$CNT, pred = test$CNT, interval = TRUE)
```

