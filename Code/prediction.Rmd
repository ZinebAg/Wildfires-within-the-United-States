---
title: "R Notebook"
output: html_notebook
---
````{r, include=FALSE}

library(ggplot2)
library(tidyr)
library(dplyr)
library(corrplot)
library(maps)
library(tidyverse)
library(Hmisc)
library(zoo)
library(hrbrthemes) 
library(pscl)
library('plot.matrix')
library('psych')
library(bookdown)
library(quantreg)
library(latex2exp)
library(cowplot)
library(reshape2)
library(stargazer)
library(knitr)
library(stargazer)
````
### Land covers and meteorogical correlation
```{r, include = FALSE}
load ("../Data/data_train_DF.RData")
df <- data_train_DF
#Remove the NA values from the data
df<-df[!is.na(df$CNT),] 
df<-df[!is.na(df$BA),]
```


We want to understand the correlation between land covers and meteorological variables. To do so, we are going to clean our data first, rename the variables by their description so that we can easily analyze our results and then compute the correlation between the variables. The problem is that when trying to output the matrix, we get a warning saying that the matrix is too big. To get an glimpse of what variable can be highly related, we are going to output the correlation between a pair of land cover and meteorological variable when it is bigger than a threshold manually set.


```{r, echo = FALSE}
remove = c("CNT","BA","lon","lat","area","year","month","altiMean","altiSD")
data =df[, -which(names(df)%in% remove)]
data<-data%>% dplyr::rename(CR=lc1,CRherb = lc2, MosaicC = lc3, MosaicVege = lc4,
                            TBE=lc5,TBD = lc6, TNE  = lc7, TND = lc8, TreeMixed =lc9,
                            MosaicTreeShrub= lc10, Shrub= lc11, Grass = lc12,
                            Svege=lc13,
                            TreeFlood=lc14,ShrubFlood = lc15, urban = lc16, 
                            BareAreas =lc17, Water = lc18,NSwind=clim1, WEwind=clim2, 
                            dew_temperature=clim3, temperature=clim4, 
                            potential_evaporation=clim5, solar_radiation= clim6,
                            thermal_radiation=clim7, pressure=clim8, evaporation=clim9, 
                            precipitation=clim10)
df
```


```{r,tab.cap="Table of Zero Poisson regression results", echo = FALSE}
m1<-zeroinfl(CNT~lc1+lc2+lc3+lc4+lc5+lc6+lc7+lc8+lc9+lc10+lc11+lc12+lc13+lc14+lc15+lc16+lc17+lc18
             , data = df)
summary(m1)
```



Below, you can find a block of output containing Poisson regression coefficients for each of the variables along with the standard errors, z-score and p-values for the coefficients. A second block follows with the inflation model which includes logit coefficients for predicting excess zeros. All of the predictions in both the count and inflation portion are statistically significant ( all p-values are very small) except for the land cover 3 in the count model. But otherwise this means that the null hypothesis that the coefficient is equal to 0 is rejected for all the coefficients. Hence this model fits the data significantly better than the null model.

## Prediction of the number of fire depending of the land covers : 

We are going to divide our data set  in two sets : the training set to build the model and a test set to predict the number of fires per grid. One way to split our data is to take all the data all data from 1993 to 2014 and predict the number of fire in 2015. Or also, we can randomly select 70% of our data to train and the rest to test the data. We will use the first technique split: 



```{r, echo = FALSE}
test <- subset(df, year ==2015)
train <- subset(df, year != 2015)
m1<-zeroinfl(CNT~lc1+lc2+lc3+lc4+lc5+lc6+lc7+lc8+lc9+lc10+lc11+lc12+lc13+lc14+lc15+lc16+lc17+lc18+, data = train)
#check if the actual model is better to a null null mode without predictors : 
mnull <- update(m1, .~1)
pchisq (2* (logLik(m1)-logLik(mnull)), df =18, lower.tail = FALSE)
```


Since we have 18 predictor variable in the model, we take 18 degrees of freedom for the chi-squred test. Our model is statistically significant.


```{r, echo = FALSE}
stay = c("lc1","lc2","lc3","lc4","lc5","lc6","lc7","lc8","lc9","lc10","lc11","lc12","lc13","lc14","lc15","lc16","lc17","lc18")
new_test = test[, which(names(df)%in% stay)]
#test$CNT <- predict(m1, )
new_test$CNT<- predict(m1,new_test)
new_test

```

```{r, echo = FALSE}
plot(new_test$CNT,test$CNT, xlab = "Predicted Values", ylab = "Observed Values")
```

```{r, echo = FALSE}
#effect_plot(new_test$CNT, pred = test$CNT, interval = TRUE)
#ggplot(new_test, aes(y = CNT, colour = factor(lc1))) +
 # geom_point() +
 #  geom_line() +
  #labs(x = "Number of Children", y = "Predicted Fish Caught")
#maybe compute the accuracy of the model 
```

```{r, echo = FALSE}

```
